From 749eee7f42d38104984429aa0517aef33931325e Mon Sep 17 00:00:00 2001
From: Sivasubramaniyan Padmanaban <sivasubramaniyan.padmanaban@analog.com>
Date: Wed, 12 Nov 2025 15:18:19 +0530
Subject: [PATCH 3/3] drivers: pwm: Fix driver handling and GPIO integration

Improve consistency between the PWM core and the GPIO PWM driver.
This change ensures correct polarity handling and initialization flow
across drivers using the PWM framework.

Signed-off-by: Sivasubramaniyan Padmanaban <sivasubramaniyan.padmanaban@analog.com>
---
 drivers/pwm/core.c     |  30 ++++
 drivers/pwm/pwm-gpio.c | 364 +++++++++++++++++++++--------------------
 include/linux/pwm.h    |  23 +++
 3 files changed, 243 insertions(+), 174 deletions(-)

diff --git a/drivers/pwm/core.c b/drivers/pwm/core.c
index 3697781c0179..03f5ebfd037e 100644
--- a/drivers/pwm/core.c
+++ b/drivers/pwm/core.c
@@ -1084,6 +1084,36 @@ static void of_pwmchip_remove(struct pwm_chip *chip)
 		of_node_put(pwmchip_parent(chip)->of_node);
 }
 
+/**
+ * pwm_set_chip_data() - set private chip data for a PWM
+ * @pwm: PWM device
+ * @data: pointer to chip-specific data
+ *
+ * Returns: 0 on success or a negative error code on failure.
+ */
+int pwm_set_chip_data(struct pwm_device *pwm, void *data)
+{
+	if (!pwm)
+		return -EINVAL;
+
+	pwm->chip_data = data;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pwm_set_chip_data);
+
+/**
+ * pwm_get_chip_data() - get private chip data for a PWM
+ * @pwm: PWM device
+ *
+ * Returns: A pointer to the chip-private data for the PWM device.
+ */
+void *pwm_get_chip_data(struct pwm_device *pwm)
+{
+	return pwm ? pwm->chip_data : NULL;
+}
+EXPORT_SYMBOL_GPL(pwm_get_chip_data);
+
 static bool pwm_ops_check(const struct pwm_chip *chip)
 {
 	const struct pwm_ops *ops = chip->ops;
diff --git a/drivers/pwm/pwm-gpio.c b/drivers/pwm/pwm-gpio.c
index 9f8884ac7504..a5bc80be28c8 100644
--- a/drivers/pwm/pwm-gpio.c
+++ b/drivers/pwm/pwm-gpio.c
@@ -1,241 +1,257 @@
-// SPDX-License-Identifier: GPL-2.0-only
 /*
- * Generic software PWM for modulating GPIOs
+ * Copyright (c) 2015 Olliver Schinagl <oliver@schinagl.nl>
  *
- * Copyright (C) 2020 Axis Communications AB
- * Copyright (C) 2020 Nicola Di Lieto
- * Copyright (C) 2024 Stefan Wahren
- * Copyright (C) 2024 Linus Walleij
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This driver adds a high-resolution timer based PWM driver. Since this is a
+ * bit-banged driver, accuracy will always depend on a lot of factors, such as
+ * GPIO toggle speed and system load.
  */
 
-#include <linux/cleanup.h>
-#include <linux/container_of.h>
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/gpio/consumer.h>
-#include <linux/hrtimer.h>
-#include <linux/math.h>
-#include <linux/module.h>
 #include <linux/mod_devicetable.h>
-#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
 #include <linux/property.h>
 #include <linux/pwm.h>
-#include <linux/spinlock.h>
-#include <linux/time.h>
-#include <linux/types.h>
-
-struct pwm_gpio {
-	struct hrtimer gpio_timer;
-	struct gpio_desc *gpio;
-	struct pwm_state state;
-	struct pwm_state next_state;
-
-	/* Protect internal state between pwm_ops and hrtimer */
-	spinlock_t lock;
-
-	bool changing;
-	bool running;
-	bool level;
-};
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
 
-static void pwm_gpio_round(struct pwm_state *dest, const struct pwm_state *src)
-{
-	u64 dividend;
-	u32 remainder;
+enum hrtimer_restart gpio_pwm_timer(struct hrtimer *timer);
 
-	*dest = *src;
+struct gpio_pwm_data {
+	struct hrtimer timer;
+	struct gpio_desc *gpiod;
+	bool polarity;
+	bool pin_on;
+	int on_time;
+	int off_time;
+	bool run;
+};
 
-	/* Round down to hrtimer resolution */
-	dividend = dest->period;
-	remainder = do_div(dividend, hrtimer_resolution);
-	dest->period -= remainder;
+struct gpio_pwm_chip {
+	struct pwm_chip chip;
+};
 
-	dividend = dest->duty_cycle;
-	remainder = do_div(dividend, hrtimer_resolution);
-	dest->duty_cycle -= remainder;
+static void gpio_pwm_off(struct gpio_pwm_data *gpio_data)
+{
+	gpiod_set_value_cansleep(gpio_data->gpiod, gpio_data->polarity ? 1 : 0);
 }
 
-static u64 pwm_gpio_toggle(struct pwm_gpio *gpwm, bool level)
+static void gpio_pwm_on(struct gpio_pwm_data *gpio_data)
 {
-	const struct pwm_state *state = &gpwm->state;
-	bool invert = state->polarity == PWM_POLARITY_INVERSED;
+	gpiod_set_value_cansleep(gpio_data->gpiod, gpio_data->polarity ? 0 : 1);
+}
 
-	gpwm->level = level;
-	gpiod_set_value(gpwm->gpio, gpwm->level ^ invert);
+enum hrtimer_restart gpio_pwm_timer(struct hrtimer *timer)
+{
+	struct gpio_pwm_data *gpio_data = container_of(timer,
+						      struct gpio_pwm_data,
+						      timer);
+	if (!gpio_data->run) {
+		gpio_pwm_off(gpio_data);
+		gpio_data->pin_on = false;
+		return HRTIMER_NORESTART;
+	}
 
-	if (!state->duty_cycle || state->duty_cycle == state->period) {
-		gpwm->running = false;
-		return 0;
+	if (!gpio_data->pin_on) {
+		hrtimer_forward_now(&gpio_data->timer,
+				    ns_to_ktime(gpio_data->on_time));
+		gpio_pwm_on(gpio_data);
+		gpio_data->pin_on = true;
+	} else {
+		hrtimer_forward_now(&gpio_data->timer,
+				    ns_to_ktime(gpio_data->off_time));
+		gpio_pwm_off(gpio_data);
+		gpio_data->pin_on = false;
 	}
 
-	gpwm->running = true;
-	return level ? state->duty_cycle : state->period - state->duty_cycle;
+	return HRTIMER_RESTART;
 }
 
-static enum hrtimer_restart pwm_gpio_timer(struct hrtimer *gpio_timer)
+static int gpio_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			    int duty_ns, int period_ns)
 {
-	struct pwm_gpio *gpwm = container_of(gpio_timer, struct pwm_gpio,
-					     gpio_timer);
-	u64 next_toggle;
-	bool new_level;
-
-	guard(spinlock_irqsave)(&gpwm->lock);
-
-	/* Apply new state at end of current period */
-	if (!gpwm->level && gpwm->changing) {
-		gpwm->changing = false;
-		gpwm->state = gpwm->next_state;
-		new_level = !!gpwm->state.duty_cycle;
-	} else {
-		new_level = !gpwm->level;
-	}
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
 
-	next_toggle = pwm_gpio_toggle(gpwm, new_level);
-	if (next_toggle)
-		hrtimer_forward(gpio_timer, hrtimer_get_expires(gpio_timer),
-				ns_to_ktime(next_toggle));
+	gpio_data->on_time = duty_ns;
+	gpio_data->off_time = period_ns - duty_ns;
 
-	return next_toggle ? HRTIMER_RESTART : HRTIMER_NORESTART;
+	return 0;
 }
 
-static int pwm_gpio_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			  const struct pwm_state *state)
+static int gpio_pwm_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,
+				 enum pwm_polarity polarity)
 {
-	struct pwm_gpio *gpwm = pwmchip_get_drvdata(chip);
-	bool invert = state->polarity == PWM_POLARITY_INVERSED;
-
-	if (state->duty_cycle && state->duty_cycle < hrtimer_resolution)
-		return -EINVAL;
-
-	if (state->duty_cycle != state->period &&
-	    (state->period - state->duty_cycle < hrtimer_resolution))
-		return -EINVAL;
-
-	if (!state->enabled) {
-		hrtimer_cancel(&gpwm->gpio_timer);
-	} else if (!gpwm->running) {
-		int ret;
-
-		/*
-		 * This just enables the output, but pwm_gpio_toggle()
-		 * really starts the duty cycle.
-		 */
-		ret = gpiod_direction_output(gpwm->gpio, invert);
-		if (ret)
-			return ret;
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
+	struct gpio_desc *gpiod;
+
+	dev_info(&chip->dev, "Entered: %s polarity: %d\n", __func__, polarity);
+	if(polarity == PWM_POLARITY_NORMAL){
+		gpiod = devm_gpiod_get(&chip->dev, "pwm", GPIOD_OUT_LOW);
+		if (IS_ERR(gpiod)) {
+			dev_err(&chip->dev, "Failed to get \"pwm\" gpio\n");
+			return PTR_ERR(gpiod);
+		}
+		gpio_data->gpiod = gpiod;
 	}
 
-	guard(spinlock_irqsave)(&gpwm->lock);
-
-	if (!state->enabled) {
-		pwm_gpio_round(&gpwm->state, state);
-		gpwm->running = false;
-		gpwm->changing = false;
-
-		gpiod_set_value(gpwm->gpio, invert);
-	} else if (gpwm->running) {
-		pwm_gpio_round(&gpwm->next_state, state);
-		gpwm->changing = true;
-	} else {
-		unsigned long next_toggle;
-
-		pwm_gpio_round(&gpwm->state, state);
-		gpwm->changing = false;
-
-		next_toggle = pwm_gpio_toggle(gpwm, !!state->duty_cycle);
-		if (next_toggle)
-			hrtimer_start(&gpwm->gpio_timer, next_toggle,
-				      HRTIMER_MODE_REL);
+	if(polarity == PWM_POLARITY_INVERSED) {
+		devm_gpiod_put(&chip->dev, gpio_data->gpiod);
+		gpio_data->gpiod = NULL;
 	}
 
+	gpio_data->polarity = polarity;
+
 	return 0;
 }
 
-static int pwm_gpio_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
-			       struct pwm_state *state)
+static int gpio_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 {
-	struct pwm_gpio *gpwm = pwmchip_get_drvdata(chip);
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
 
-	guard(spinlock_irqsave)(&gpwm->lock);
+	if (gpio_data->run)
+		return -EBUSY;
 
-	if (gpwm->changing)
-		*state = gpwm->next_state;
-	else
-		*state = gpwm->state;
+	gpio_data->run = true;
+	if (gpio_data->off_time) {
+		hrtimer_start(&gpio_data->timer, ktime_set(0, 0),
+			      HRTIMER_MODE_REL);
+	} else {
+		if (gpio_data->on_time)
+			gpio_pwm_on(gpio_data);
+		else
+			gpio_pwm_off(gpio_data);
+	}
 
 	return 0;
 }
 
-static const struct pwm_ops pwm_gpio_ops = {
-	.apply = pwm_gpio_apply,
-	.get_state = pwm_gpio_get_state,
-};
-
-static void pwm_gpio_disable_hrtimer(void *data)
+static void gpio_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
 {
-	struct pwm_gpio *gpwm = data;
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
 
-	hrtimer_cancel(&gpwm->gpio_timer);
+	gpio_data->run = false;
+	if (!gpio_data->off_time)
+		gpio_pwm_off(gpio_data);
 }
 
-static int pwm_gpio_probe(struct platform_device *pdev)
+static const struct pwm_ops gpio_pwm_ops = {
+	.config = gpio_pwm_config,
+	.set_polarity = gpio_pwm_set_polarity,
+	.enable = gpio_pwm_enable,
+	.disable = gpio_pwm_disable,
+	.owner = THIS_MODULE,
+};
+
+static int gpio_pwm_probe(struct platform_device *pdev)
 {
-	struct device *dev = &pdev->dev;
-	struct pwm_chip *chip;
-	struct pwm_gpio *gpwm;
+	struct gpio_desc *gpiod;
+	struct gpio_pwm_data *gpio_data;
+	struct gpio_pwm_chip *gpio_chip;
+	int hrtimer = 0;
 	int ret;
 
-	chip = devm_pwmchip_alloc(dev, 1, sizeof(*gpwm));
-	if (IS_ERR(chip))
-		return PTR_ERR(chip);
+	gpio_chip = devm_kzalloc(&pdev->dev, sizeof(*gpio_chip), GFP_KERNEL);
+	if (!gpio_chip)
+		return -ENOMEM;
+
+	gpio_chip->chip.dev = pdev->dev;
+	gpio_chip->chip.ops = &gpio_pwm_ops;
+	gpio_chip->chip.base = -1;
+	gpio_chip->chip.npwm = 1;
+	gpio_chip->chip.of_xlate = of_pwm_xlate_with_flags;
+	gpio_chip->chip.of_pwm_n_cells = 3;
 
-	gpwm = pwmchip_get_drvdata(chip);
+	ret = pwmchip_add(&gpio_chip->chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);
+		return ret;
+	}
 
-	spin_lock_init(&gpwm->lock);
+	gpiod = devm_gpiod_get(&pdev->dev, "pwm", GPIOD_OUT_LOW);
+	if (IS_ERR(gpiod)) {
+		int error;
 
-	gpwm->gpio = devm_gpiod_get(dev, NULL, GPIOD_ASIS);
-	if (IS_ERR(gpwm->gpio))
-		return dev_err_probe(dev, PTR_ERR(gpwm->gpio),
-				     "%pfw: could not get gpio\n",
-				     dev_fwnode(dev));
+		error = PTR_ERR(gpiod);
+		if (error != -EPROBE_DEFER)
+			dev_err(&pdev->dev,
+				"failed to get gpio flags, error: %d\n",
+				error);
+		return error;
+	}
 
-	if (gpiod_cansleep(gpwm->gpio))
-		return dev_err_probe(dev, -EINVAL,
-				     "%pfw: sleeping GPIO not supported\n",
-				     dev_fwnode(dev));
+	gpio_data = devm_kzalloc(&pdev->dev, sizeof(*gpio_data),
+				 GFP_KERNEL);
 
-	chip->ops = &pwm_gpio_ops;
-	chip->atomic = true;
+	hrtimer_init(&gpio_data->timer,
+		     CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	gpio_data->timer.function = &gpio_pwm_timer;
+	gpio_data->gpiod = gpiod;
+	gpio_data->pin_on = false;
+	gpio_data->run = false;
 
-	hrtimer_init(&gpwm->gpio_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	ret = devm_add_action_or_reset(dev, pwm_gpio_disable_hrtimer, gpwm);
-	if (ret)
-		return ret;
+	if (hrtimer_is_hres_active(&gpio_data->timer))
+		hrtimer++;
+
+	pwm_set_chip_data(&gpio_chip->chip.pwms[0], gpio_data);
+
+	if (!hrtimer) {
+		dev_warn(&pdev->dev, "unable to use High-Resolution timer,");
+		dev_warn(&pdev->dev, "%s is restricted to low resolution.",
+			  "pwm-gpio");
+	}
 
-	gpwm->gpio_timer.function = pwm_gpio_timer;
+	platform_set_drvdata(pdev, gpio_chip);
 
-	ret = pwmchip_add(chip);
-	if (ret < 0)
-		return dev_err_probe(dev, ret, "could not add pwmchip\n");
+	dev_dbg(&pdev->dev, "GPIO PWMs loaded\n");
 
 	return 0;
 }
 
-static const struct of_device_id pwm_gpio_dt_ids[] = {
-	{ .compatible = "pwm-gpio" },
-	{ /* sentinel */ }
+static void gpio_pwm_remove(struct platform_device *pdev)
+{
+	struct gpio_pwm_chip *gpio_chip;
+	struct gpio_pwm_data *gpio_data;
+
+	gpio_chip = platform_get_drvdata(pdev);
+	gpio_data = pwm_get_chip_data(&gpio_chip->chip.pwms[0]);
+
+	hrtimer_cancel(&gpio_data->timer);
+	pwmchip_remove(&gpio_chip->chip);
+
+}
+
+static const struct of_device_id gpio_pwm_of_match[] = {
+	{ .compatible = "pwm-gpio", },
+	{/* sentinel */},
 };
-MODULE_DEVICE_TABLE(of, pwm_gpio_dt_ids);
+MODULE_DEVICE_TABLE(of, gpio_pwm_of_match);
 
-static struct platform_driver pwm_gpio_driver = {
+static struct platform_driver gpio_pwm_driver = {
+	.probe = gpio_pwm_probe,
+	.remove = gpio_pwm_remove,
 	.driver = {
 		.name = "pwm-gpio",
-		.of_match_table = pwm_gpio_dt_ids,
+		.of_match_table = of_match_ptr(gpio_pwm_of_match),
 	},
-	.probe = pwm_gpio_probe,
 };
-module_platform_driver(pwm_gpio_driver);
+module_platform_driver(gpio_pwm_driver);
 
-MODULE_DESCRIPTION("PWM GPIO driver");
-MODULE_AUTHOR("Vincent Whitchurch");
+MODULE_AUTHOR("Olliver Schinagl <oliver@schinagl.nl>");
+MODULE_DESCRIPTION("Generic GPIO bit-banged PWM driver");
 MODULE_LICENSE("GPL");
diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 8acd60b53f58..d28ba2eabc08 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -74,6 +74,7 @@ struct pwm_state {
  * @flags: flags associated with the PWM device
  * @hwpwm: per-chip relative index of the PWM device
  * @chip: PWM chip providing this PWM device
+ * @chip_data: chip-private data associated with the PWM device
  * @args: PWM arguments
  * @state: last applied state
  * @last: last implemented state (for PWM_DEBUG)
@@ -83,6 +84,7 @@ struct pwm_device {
 	unsigned long flags;
 	unsigned int hwpwm;
 	struct pwm_chip *chip;
+	void *chip_data;
 
 	struct pwm_args args;
 	struct pwm_state state;
@@ -253,6 +255,11 @@ struct pwm_capture {
  * @capture: capture and report PWM signal
  * @apply: atomically apply a new PWM config
  * @get_state: get the current PWM state.
+ * @owner: helps prevent removal of modules exporting active PWMs
+ * @config: configure duty cycles and period length for this PWM
+ * @set_polarity: configure the polarity of this PWM
+ * @enable: enable PWM output toggling
+ * @disable: disable PWM output toggling
  */
 struct pwm_ops {
 	int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);
@@ -263,16 +270,28 @@ struct pwm_ops {
 		     const struct pwm_state *state);
 	int (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,
 			 struct pwm_state *state);
+	struct module *owner;
+
+	/* Only used by legacy drivers */
+	int (*config)(struct pwm_chip *chip, struct pwm_device *pwm,
+			int duty_ns, int period_ns);
+	int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm,
+			enum pwm_polarity polarity);
+	int (*enable)(struct pwm_chip *chip, struct pwm_device *pwm);
+	void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm);
+
 };
 
 /**
  * struct pwm_chip - abstract a PWM controller
  * @dev: device providing the PWMs
  * @ops: callbacks for this PWM controller
+ * @base: number of first PWM controlled by this chip
  * @owner: module providing this chip
  * @id: unique number of this PWM chip
  * @npwm: number of PWMs controlled by this chip
  * @of_xlate: request a PWM device given a device tree PWM specifier
+ * @of_pwm_n_cells: number of cells expected in the device tree PWM specifier
  * @atomic: can the driver's ->apply() be called in atomic context
  * @uses_pwmchip_alloc: signals if pwmchip_allow was used to allocate this chip
  * @pwms: array of PWM devices allocated by the framework
@@ -280,12 +299,14 @@ struct pwm_ops {
 struct pwm_chip {
 	struct device dev;
 	const struct pwm_ops *ops;
+	int base;
 	struct module *owner;
 	unsigned int id;
 	unsigned int npwm;
 
 	struct pwm_device * (*of_xlate)(struct pwm_chip *chip,
 					const struct of_phandle_args *args);
+	unsigned int of_pwm_n_cells;
 	bool atomic;
 
 	/* only used internally by the PWM framework */
@@ -398,6 +419,8 @@ void pwmchip_put(struct pwm_chip *chip);
 struct pwm_chip *pwmchip_alloc(struct device *parent, unsigned int npwm, size_t sizeof_priv);
 struct pwm_chip *devm_pwmchip_alloc(struct device *parent, unsigned int npwm, size_t sizeof_priv);
 
+int pwm_set_chip_data(struct pwm_device *pwm, void *data);
+void *pwm_get_chip_data(struct pwm_device *pwm);
 int __pwmchip_add(struct pwm_chip *chip, struct module *owner);
 #define pwmchip_add(chip) __pwmchip_add(chip, THIS_MODULE)
 void pwmchip_remove(struct pwm_chip *chip);
-- 
2.25.1

