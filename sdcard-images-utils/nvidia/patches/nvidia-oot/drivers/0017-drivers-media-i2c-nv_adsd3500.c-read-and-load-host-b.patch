From 09d906d3962ce5d4583b3bbbb5836158eebf27b6 Mon Sep 17 00:00:00 2001
From: Sivasubramaniyan Padmanaban <sivasubramaniyan.padmanaban@analog.com>
Date: Fri, 10 Oct 2025 14:00:36 +0530
Subject: [PATCH] drivers: media: i2c: nv_adsd3500.c: read and load host boot
 firmware

Signed-off-by: Sivasubramaniyan Padmanaban <sivasubramaniyan.padmanaban@analog.com>
---
 drivers/media/i2c/adsd3500_regs.h |   5 +-
 drivers/media/i2c/nv_adsd3500.c   | 223 ++++++++++++++++++++++++++++--
 2 files changed, 219 insertions(+), 9 deletions(-)

diff --git a/drivers/media/i2c/adsd3500_regs.h b/drivers/media/i2c/adsd3500_regs.h
index 29eee39e..626d8987 100644
--- a/drivers/media/i2c/adsd3500_regs.h
+++ b/drivers/media/i2c/adsd3500_regs.h
@@ -11,7 +11,7 @@
 
 #include <linux/bitfield.h>
 
-#define DRIVER_VERSION 			    "6.1.0"
+#define DRIVER_VERSION 			    "6.2.0"
 #define GET_CHIP_ID_CMD                     0x0112
 
 #define STREAM_ON_CMD                       0x00AD
@@ -69,5 +69,8 @@
 #define INTR_TRIGGER			    0x0001
 #define USER_TASK 			    _IOW('A',1,int32_t*)
 #define SIGETX				    44
+#define ADSD3500_FIRMWARE		    "adi/adsd3500-fw.bin"
+#define HEADER_SIZE_IN_BYTES                16
+#define PAYLOAD_MAX_CHUNK_SIZE		    2048
 
 #endif /* _ADI_ADSD3500_REGS_H_ */
diff --git a/drivers/media/i2c/nv_adsd3500.c b/drivers/media/i2c/nv_adsd3500.c
index 4f573102..c4c28406 100644
--- a/drivers/media/i2c/nv_adsd3500.c
+++ b/drivers/media/i2c/nv_adsd3500.c
@@ -11,6 +11,8 @@
 #include <linux/bitfield.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/pwm.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/of.h>
@@ -33,6 +35,10 @@
 #define ADSD3500_DEFAULT_CLK_FREQ	104250000
 #define ADSD3500_DEFAULT_FPS            10
 
+static bool fw_load = true;
+module_param(fw_load, bool, 0644);
+MODULE_PARM_DESC(fw_load, "Boolean enabling/disbaling firmware loading by driver");
+
 struct adsd3500_mode_info {
 	uint32_t width;
 	uint32_t height;
@@ -66,6 +72,7 @@ struct adsd3500 {
 
 	struct v4l2_ctrl_handler 	ctrl_handler;
 
+	const struct firmware  		*main_fw;
 	struct mutex 			lock;
 	bool 				streaming;
 	s64 				framerate;
@@ -80,18 +87,20 @@ struct adsd3500 {
 	struct task_struct 		*task;
 };
 
-#define V4L2_CID_ADSD3500_OPERATING_MODE  (V4L2_CID_USER_ADITOF_BASE + 0)
-#define V4L2_CID_ADSD3500_CHIP_CONFIG (V4L2_CID_USER_ADITOF_BASE + 1)
-#define V4L2_CID_ADSD3500_DEPTH_BITS (V4L2_CID_USER_ADITOF_BASE + 2)
-#define V4L2_CID_ADSD3500_AB_BITS (V4L2_CID_USER_ADITOF_BASE + 3)
-#define V4L2_CID_ADSD3500_CONFIDENCE_BITS (V4L2_CID_USER_ADITOF_BASE + 4)
-#define V4L2_CID_ADSD3500_AB_AVG (V4L2_CID_USER_ADITOF_BASE + 5)
-#define V4L2_CID_ADSD3500_DEPTH_EN (V4L2_CID_USER_ADITOF_BASE + 6)
-#define V4L2_CID_ADSD3500_FSYNC_TRIGGER (V4L2_CID_USER_ADITOF_BASE + 7)
+#define V4L2_CID_ADSD3500_OPERATING_MODE  	(V4L2_CID_USER_ADITOF_BASE + 0)
+#define V4L2_CID_ADSD3500_CHIP_CONFIG 		(V4L2_CID_USER_ADITOF_BASE + 1)
+#define V4L2_CID_ADSD3500_DEPTH_BITS 		(V4L2_CID_USER_ADITOF_BASE + 2)
+#define V4L2_CID_ADSD3500_AB_BITS 		(V4L2_CID_USER_ADITOF_BASE + 3)
+#define V4L2_CID_ADSD3500_CONFIDENCE_BITS	(V4L2_CID_USER_ADITOF_BASE + 4)
+#define V4L2_CID_ADSD3500_AB_AVG 		(V4L2_CID_USER_ADITOF_BASE + 5)
+#define V4L2_CID_ADSD3500_DEPTH_EN 		(V4L2_CID_USER_ADITOF_BASE + 6)
+#define V4L2_CID_ADSD3500_FSYNC_TRIGGER 	(V4L2_CID_USER_ADITOF_BASE + 7)
+#define V4L2_CID_ADSD3500_LOAD_FIRMWARE 	(V4L2_CID_USER_ADITOF_BASE + 8)
 
 ssize_t debug_read(struct file *file, char __user *buff, size_t count, loff_t *offset);
 ssize_t debug_write(struct file *file, const char __user *buff, size_t count, loff_t *offset);
 static int adsd3500_set_fsync_trigger(struct adsd3500 *adsd3500, s32 val);
+static int adsd3500_load_firmware(struct v4l2_subdev *sd);
 
 static const struct reg_sequence adsd3500_powerup_setting[] = {
 };
@@ -576,6 +585,9 @@ static int adsd3500_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_ADSD3500_FSYNC_TRIGGER:
 		ret = adsd3500_set_fsync_trigger(adsd3500, ctrl->val);
 		break;
+	case V4L2_CID_ADSD3500_LOAD_FIRMWARE:
+		ret = adsd3500_load_firmware(adsd3500->sd);
+		break;
 	case TEGRA_CAMERA_CID_FRAME_RATE:
 		ret = adsd3500_set_frame_rate(adsd3500, *ctrl->p_new.p_s64);
 		break;
@@ -696,6 +708,16 @@ static const struct v4l2_ctrl_config adsd3500_ctrls[] = {
 		.max            = 1,
 		.step           = 1,
 	},
+	{
+		.ops    	= &adsd3500_ctrl_ops,
+		.id     	= V4L2_CID_ADSD3500_LOAD_FIRMWARE,
+		.name   	= "Load Firmware",
+		.type   	= V4L2_CTRL_TYPE_INTEGER,
+		.def    	= 0,
+		.min    	= 0,
+		.max    	= 1,
+		.step   	= 1,
+	},
 	{
 		.ops 		= &adsd3500_ctrl_ops,
 		.id 		= TEGRA_CAMERA_CID_FRAME_RATE,
@@ -1133,6 +1155,189 @@ error:
 	return NULL;
 }
 
+static int adsd3500_read_ack(struct v4l2_subdev *sd){
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct adsd3500 *adsd3500 = (struct adsd3500 *)s_data->priv;
+	uint8_t read_val[4];
+	int ret;
+
+	ret = i2c_master_recv(client, read_val, sizeof(read_val));
+	if (ret < 0) {
+		dev_err(adsd3500->dev, "Read ACK cmd failed.\n");
+		return -EIO;
+	}
+	else{
+	// Verify the acknowledgement success command op-code from the received response
+		if (read_val[0] != 0x0B) {
+			dev_err(adsd3500->dev, "ACK ERROR response d0: %02X  d1: %02X d2: %02X d3: %02X\n", read_val[0], read_val[1], read_val[2], read_val[3]);
+			return -ENXIO;
+		}
+		dev_dbg(adsd3500->dev, "ACK Received\n");
+	}
+
+	return 0;
+}
+
+static int adsd3500_send_host_boot_data(struct v4l2_subdev *sd, uint8_t* data, int size)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct adsd3500 *adsd3500 = (struct adsd3500 *)s_data->priv;
+	int n_segments = 0, prev_seg_end = 0, curr_segment= 0;
+	int position = 0, location = 0;
+	int segment_start[100], segment_end[100], segment_size[100];
+	int header_start[100], header_end[100];
+	uint8_t header_packet[16];
+	uint8_t* data_packet = NULL;
+	int ret;
+
+	dev_dbg(adsd3500->dev, "Entered: %s\n",__func__);
+
+	data_packet = (uint8_t *)kvzalloc(PAYLOAD_MAX_CHUNK_SIZE * sizeof(uint8_t),GFP_KERNEL);
+
+	while (1) {
+		segment_size[n_segments] = (data[prev_seg_end+2]<<8)|data[prev_seg_end+1];
+		segment_start[n_segments] = prev_seg_end + HEADER_SIZE_IN_BYTES;
+		segment_end[n_segments] = segment_start[n_segments] + segment_size[n_segments];
+		header_start[n_segments] = segment_start[n_segments] - HEADER_SIZE_IN_BYTES;
+		header_end[n_segments] = segment_start[n_segments] - 1;
+		prev_seg_end = segment_end[n_segments];
+		n_segments++;
+		if (prev_seg_end >= size) {
+			break;
+		}
+	}
+
+	dev_info(adsd3500->dev, "No of headers =%02d\n", n_segments);
+
+	while (curr_segment < n_segments){
+		location = header_start[curr_segment];
+		memcpy(header_packet, &data[location], HEADER_SIZE_IN_BYTES);
+		dev_dbg(adsd3500->dev,"Current Segment = %d header_start = %d\n Size= %04X", curr_segment + 1, header_start[curr_segment], segment_size[curr_segment]);
+		dev_dbg(adsd3500->dev, "Send Header data\n");
+		ret = i2c_master_send(client, header_packet, HEADER_SIZE_IN_BYTES);
+		if (ret < 0) {
+			dev_err(adsd3500->dev, "Failed to write the header packet of segment %d\n", curr_segment + 1);
+			return -EIO;
+		}
+		// Check for the RESET command op-code and skip the read acknowledgement
+		if (header_packet[03] == 0x55) {
+			dev_info(adsd3500->dev, "Firmware transfer Compelete\n");
+			break;
+		}
+		ret = adsd3500_read_ack(sd);
+		if(ret < 0) {
+			dev_err(adsd3500->dev, "Failed to read the acknowledgement header packet segment: %d\n", curr_segment + 1);
+			return -ENXIO;
+		}
+		msleep(5);
+
+		if(segment_size[curr_segment] != 0){
+			location = segment_start[curr_segment];
+			memcpy(data_packet, &data[location], segment_size[curr_segment]);
+			dev_dbg(adsd3500->dev, "Send Payload data\n");
+			ret = i2c_master_send(client, data_packet, segment_size[curr_segment]);
+			if (ret < 0) {
+				dev_err(adsd3500->dev, "Failed to write the payload data of segment %d\n",curr_segment + 1);
+				return -EIO;
+			}
+			msleep(5);
+			ret = adsd3500_read_ack(sd);
+			if(ret < 0) {
+				dev_err(adsd3500->dev, "Failed to read the acknowledgement payload data segment: %d\n", curr_segment + 1);
+				return -ENXIO;
+			}
+		}
+		msleep(1);
+
+		memset(header_packet, 0, sizeof(header_packet));
+		memset(data_packet, 0, PAYLOAD_MAX_CHUNK_SIZE * sizeof(uint8_t));
+		position=0;
+		curr_segment++;
+	}
+
+	kfree(data_packet);
+
+	return 0;
+}
+
+static int adsd3500_parse_fw(struct v4l2_subdev *sd)
+{
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct adsd3500 *adsd3500 = (struct adsd3500 *)s_data->priv;
+	const struct firmware *fw = adsd3500->main_fw;
+	uint8_t* data_fw_3500 = NULL;
+	size_t data_fw_3500_size = 0;
+	int ret;
+
+	dev_dbg(adsd3500->dev, "Entered: %s\n",__func__);
+
+	data_fw_3500_size = fw->size;
+	dev_info(adsd3500->dev, "Firmware size = %ld\n",data_fw_3500_size);
+	data_fw_3500 = (uint8_t *)kvzalloc(data_fw_3500_size * sizeof(uint8_t),GFP_KERNEL);
+	if(!data_fw_3500){
+		dev_err(adsd3500->dev, "Failed to allocate memory for FW data\n");
+		return -ENOMEM;
+	}
+
+	memcpy(data_fw_3500, fw->data, data_fw_3500_size);
+	dev_dbg(adsd3500->dev, "FW data 1:%02X  2:%02X  3:%02X  4:%02X\n",data_fw_3500[0], data_fw_3500[1], data_fw_3500[2], data_fw_3500[3]);
+	ret = adsd3500_send_host_boot_data(sd, data_fw_3500, data_fw_3500_size);
+	if(ret != 0){
+		dev_err(adsd3500->dev, "Failed to send the host boot firmware\n");
+		kfree(data_fw_3500);
+		return ret;
+	};
+
+	kfree(data_fw_3500);
+
+	return 0;
+}
+
+static int adsd3500_load_firmware(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct adsd3500 *adsd3500 = (struct adsd3500 *)s_data->priv;
+	int ret;
+
+	dev_dbg(adsd3500->dev, "Entered: %s\n",__func__);
+
+	if(fw_load){
+		dev_dbg(adsd3500->dev, "Request ADSD3500 firmware file\n");
+		ret = request_firmware(&adsd3500->main_fw, ADSD3500_FIRMWARE, adsd3500->dev);
+		if(ret < 0) {
+			dev_err(adsd3500->dev, "Failed to read firmware\n");
+			goto release_firmware;
+		}
+		else {
+			ret = adsd3500_parse_fw(sd);
+			if(ret < 0){
+				dev_err(adsd3500->dev, "Failed to parse the firmware\n");
+				goto release_firmware;
+				return ret;
+			}
+		}
+	}
+
+	release_firmware(adsd3500->main_fw);
+
+	return 0;
+
+release_firmware:
+	release_firmware(adsd3500->main_fw);
+	return ret;
+
+}
+
 MODULE_DEVICE_TABLE(of, adsd3500_of_match);
 
 static struct camera_common_sensor_ops adsd3500_common_ops = {
@@ -1254,6 +1459,7 @@ static int adsd3500_probe(struct i2c_client *client,
 	dev_dbg(&client->dev, "Lanes nr: %u\n", priv->current_config.nr_mipi_lanes);
 
 	v4l2_i2c_subdev_init(priv->sd, client, &adsd3500_subdev_ops);
+	//v4l2_set_subdevdata(priv->sd, priv);
 
 	ret= adsd3500_debugfs_init(priv);
 	if(ret < 0){
@@ -1355,5 +1561,6 @@ module_i2c_driver(adsd3500_i2c_driver);
 
 MODULE_DESCRIPTION("Analog Devices ADSD3500 Driver");
 MODULE_AUTHOR("Bogdan Togorean");
+MODULE_AUTHOR("Sivasubramaniyan Padmanaban");
 MODULE_LICENSE("GPL v2");
 MODULE_VERSION(DRIVER_VERSION);
-- 
2.25.1

